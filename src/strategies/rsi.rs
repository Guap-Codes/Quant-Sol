use crate::data::ProcessedMarketData;
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;

/// Represents a Relative Strength Index (RSI) trading strategy implementation.
///
/// This struct manages the state and logic for an RSI-based trading strategy,
/// which uses price momentum to generate trading signals based on overbought
/// and oversold conditions.
///
/// # Key Features
/// * Calculates RSI using a configurable period
/// * Tracks price history, gains, and losses
/// * Generates buy, sell, or hold signals based on RSI thresholds
/// * Manages trading positions dynamically
///
/// # Fields
/// * `period`: Number of periods used for RSI calculation
/// * `oversold_threshold`: Lower RSI threshold for potential buy signals
/// * `overbought_threshold`: Upper RSI threshold for potential sell signals
/// * `price_history`: Rolling window of historical prices
/// * `gains`: Rolling window of price gains
/// * `losses`: Rolling window of price losses
/// * `position_open`: Flag indicating if a trading position is currently open
/// * `current_position`: Current trading position (long or short)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RsiStrategy {
    pub period: usize,
    pub oversold_threshold: f64,
    pub overbought_threshold: f64,
    pub price_history: VecDeque<f64>,
    pub gains: VecDeque<f64>,
    pub losses: VecDeque<f64>,
    pub position_open: bool,
    pub current_position: Option<Position>,
}

/// Represents the possible trading positions in the RSI strategy.
///
/// Indicates whether the strategy is currently positioned long (bullish)
/// or short (bearish) in the market.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum Position {
    /// Long position: Expecting price to rise
    Long,
    /// Short position: Expecting price to fall
    Short,
}

/// Represents a trading signal generated by the RSI strategy.
///
/// # Fields
/// * `timestamp`: Timestamp of the signal generation
/// * `price`: Current price at the time of the signal
/// * `rsi`: Relative Strength Index value associated with the signal
/// * `signal_type`: Type of signal (Buy, Sell, Hold)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RsiSignal {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub price: f64,
    pub rsi: Option<f64>,
    pub signal_type: SignalType,
}

/// Represents the type of trading signal generated by the strategy.
///
/// Indicates the recommended trading action based on the current market conditions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum SignalType {
    /// Buy signal: Suggests entering a long position
    Buy,
    /// Sell signal: Suggests exiting or entering a short position
    Sell,
    /// Hold signal: Suggests maintaining the current position or not trading
    Hold,
}

impl Default for RsiStrategy {
    /// Provides default configuration for the RSI trading strategy.
    ///
    /// # Default Values
    /// * `period`: 14 periods (standard RSI period)
    /// * `oversold_threshold`: 40.0 (more aggressive oversold level)
    /// * `overbought_threshold`: 60.0 (more aggressive overbought level)
    fn default() -> Self {
        Self {
            period: 14,                 // Standard 14-period RSI
            oversold_threshold: 40.0,   // More aggressive oversold level
            overbought_threshold: 60.0, // More aggressive overbought level
            price_history: VecDeque::new(),
            gains: VecDeque::new(),
            losses: VecDeque::new(),
            position_open: false,
            current_position: None,
        }
    }
}

impl RsiStrategy {
    /// Creates a new RSI strategy with custom overbought and oversold thresholds.
    ///
    /// # Arguments
    /// * `oversold_threshold`: Lower RSI threshold for potential buy signals
    /// * `overbought_threshold`: Upper RSI threshold for potential sell signals
    ///
    /// # Returns
    /// A new `RsiStrategy` instance with the specified configuration
    pub fn new(oversold_threshold: f64, overbought_threshold: f64) -> Self {
        Self {
            period: 14, // Standard 14-period RSI
            oversold_threshold,
            overbought_threshold,
            price_history: VecDeque::new(),
            gains: VecDeque::new(),
            losses: VecDeque::new(),
            position_open: false,
            current_position: None,
        }
    }

    /// Analyzes a single market data point and generates a trading signal.
    ///
    /// Calculates the Relative Strength Index (RSI) and generates a trading signal
    /// based on the current market conditions and RSI value.
    ///
    /// # Key Steps
    /// 1. Update price, gains, and losses history
    /// 2. Calculate RSI using Wilder's smoothing method
    /// 3. Generate trading signal based on RSI thresholds
    ///
    /// # Arguments
    /// * `data`: Processed market data point to analyze
    ///
    /// # Returns
    /// An `RsiSignal` with the recommended trading action and current RSI
    pub fn analyze(&mut self, data: &ProcessedMarketData) -> RsiSignal {
        // Add current price to history
        self.price_history.push_back(data.raw_data.price);

        // Calculate price change and update gains/losses
        if self.price_history.len() > 1 {
            let prev_price = self.price_history[self.price_history.len() - 2];
            let price_change = data.raw_data.price - prev_price;

            if price_change > 0.0 {
                self.gains.push_back(price_change);
                self.losses.push_back(0.0);
            } else {
                self.gains.push_back(0.0);
                self.losses.push_back(price_change.abs());
            }
        }

        // Maintain window size
        if self.price_history.len() > self.period {
            self.price_history.pop_front();
        }
        if self.gains.len() > self.period {
            self.gains.pop_front();
        }
        if self.losses.len() > self.period {
            self.losses.pop_front();
        }

        // Calculate RSI if we have enough data
        if self.gains.len() < self.period {
            return RsiSignal {
                timestamp: data.raw_data.timestamp,
                price: data.raw_data.price,
                rsi: None,
                signal_type: SignalType::Hold,
            };
        }

        let avg_gain = self.gains.iter().sum::<f64>() / self.period as f64;
        let avg_loss = self.losses.iter().sum::<f64>() / self.period as f64;

        let rs = if avg_loss == 0.0 {
            100.0
        } else {
            avg_gain / avg_loss
        };

        let rsi = 100.0 - (100.0 / (1.0 + rs));

        // Generate signal based on RSI value and current position
        let signal_type = if rsi <= self.oversold_threshold {
            if !self.position_open || self.current_position == Some(Position::Short) {
                self.position_open = true;
                self.current_position = Some(Position::Long);
                SignalType::Buy
            } else {
                SignalType::Hold
            }
        } else if rsi >= self.overbought_threshold {
            if !self.position_open || self.current_position == Some(Position::Long) {
                self.position_open = true;
                self.current_position = Some(Position::Short);
                SignalType::Sell
            } else {
                SignalType::Hold
            }
        } else if self.position_open {
            // Close position if RSI moves away from extreme levels
            match self.current_position {
                Some(Position::Long) if rsi >= 45.0 => {
                    self.position_open = false;
                    self.current_position = None;
                    SignalType::Sell
                }
                Some(Position::Short) if rsi <= 55.0 => {
                    self.position_open = false;
                    self.current_position = None;
                    SignalType::Buy
                }
                _ => SignalType::Hold,
            }
        } else {
            SignalType::Hold
        };

        RsiSignal {
            timestamp: data.raw_data.timestamp,
            price: data.raw_data.price,
            rsi: Some(rsi),
            signal_type,
        }
    }

     /// Analyzes a batch of market data points and generates trading signals.
    ///
    /// Applies the `analyze` method to each market data point in the input slice.
    /// Creates a clone of the strategy to maintain independent state for batch processing.
    ///
    /// # Arguments
    /// * `data`: Slice of processed market data points to analyze
    ///
    /// # Returns
    /// A vector of `RsiSignal` with trading signals for each data point
    pub fn analyze_batch(&self, data: &[ProcessedMarketData]) -> Vec<RsiSignal> {
        let mut signals = Vec::with_capacity(data.len());
        let mut strategy = self.clone();

        for item in data {
            signals.push(strategy.analyze(item));
        }

        signals
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data::MarketData;

    fn create_test_data(price: f64, rsi: f64) -> ProcessedMarketData {
        ProcessedMarketData {
            raw_data: MarketData {
                timestamp: chrono::Utc::now(),
                symbol: "TEST".to_string(),
                price,
                volume: 1000.0,
                high: price + 1.0,
                low: price - 1.0,
            },
            moving_average_5: Some(price),
            moving_average_20: Some(price),
            rsi_14: Some(rsi),
            volatility: Some(1.0),
            is_outlier: false,
        }
    }

    #[test]
    fn test_oversold_signal() {
        let mut strategy = RsiStrategy::default();
        let data = create_test_data(100.0, 25.0); // RSI below oversold threshold
        let signal = strategy.analyze(&data);

        assert!(matches!(signal.signal_type, SignalType::Buy));
        assert!(strategy.position_open);
        assert!(matches!(strategy.current_position, Some(Position::Long)));
    }

    #[test]
    fn test_overbought_signal() {
        let mut strategy = RsiStrategy::default();
        let data = create_test_data(100.0, 75.0); // RSI above overbought threshold
        let signal = strategy.analyze(&data);

        assert!(matches!(signal.signal_type, SignalType::Sell));
        assert!(strategy.position_open);
        assert!(matches!(strategy.current_position, Some(Position::Short)));
    }

    #[test]
    fn test_hold_signal() {
        let mut strategy = RsiStrategy::default();
        let data = create_test_data(100.0, 50.0); // RSI in neutral zone
        let signal = strategy.analyze(&data);

        assert!(matches!(signal.signal_type, SignalType::Hold));
        assert!(!strategy.position_open);
        assert!(matches!(strategy.current_position, None));
    }
}
