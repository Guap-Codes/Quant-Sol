use crate::data::ProcessedMarketData;
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;

/// Represents a Bollinger Bands trading strategy implementation.
///
/// This struct manages the state and logic for a Bollinger Bands trading strategy,
/// which uses price volatility and moving averages to generate trading signals.
///
/// # Key Features
/// * Calculates Bollinger Bands with configurable period and standard deviation
/// * Tracks price and volume history
/// * Detects market trends
/// * Generates buy, sell, or hold signals
///
/// # Fields
/// * `period`: Number of periods used for band calculation
/// * `std_dev_multiplier`: Multiplier for standard deviation bands
/// * `price_history`: Rolling window of historical prices
/// * `volume_history`: Rolling window of historical trading volumes
/// * `position_open`: Flag indicating if a trading position is currently open
/// * `current_position`: Current trading position (long or short)
/// * `trend_ma_period`: Period used for trend detection moving average
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BollingerBands {
    pub period: usize,
    pub std_dev_multiplier: f64,
    price_history: VecDeque<f64>,
    pub volume_history: VecDeque<f64>,
    pub position_open: bool,
    pub current_position: Option<Position>,
    pub trend_ma_period: usize, // For trend detection
}

/// Represents the possible trading positions in the Bollinger Bands strategy.
///
/// Indicates whether the strategy is currently positioned long (bullish)
/// or short (bearish) in the market.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq)]
pub enum Position {
    /// Long position: Expecting price to rise
    Long,
    /// Short position: Expecting price to fall
    Short,
}

/// Represents the Bollinger Bands levels for a given price point.
///
/// Contains the upper, middle, and lower bands used for trading signal generation.
///
/// # Fields
/// * `upper`: Upper band (typically 2 standard deviations above the moving average)
/// * `middle`: Middle band (simple moving average)
/// * `lower`: Lower band (typically 2 standard deviations below the moving average)
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BandLevels {
    pub upper: f64,
    pub middle: f64,
    pub lower: f64,
}

/// Represents a trading signal generated by the Bollinger Bands strategy.
///
/// Encapsulates the details of a potential trading action at a specific point in time.
///
/// # Fields
/// * `timestamp`: The time of the signal generation
/// * `price`: The current market price
/// * `bands`: The Bollinger Bands levels
/// * `signal_type`: The recommended trading action
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BollingerSignal {
    pub timestamp: chrono::DateTime<chrono::Utc>,
    pub price: f64,
    pub bands: BandLevels,
    pub signal_type: SignalType,
}

/// Represents the type of trading signal generated by the strategy.
///
/// Indicates the recommended trading action based on the current market conditions.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SignalType {
    /// Buy signal: Suggests entering a long position
    Buy,
    /// Sell signal: Suggests exiting or entering a short position
    Sell,
    /// Hold signal: Suggests maintaining the current position or not trading
    Hold,
}

impl Default for BollingerBands {
    /// Provides default configuration for the Bollinger Bands strategy.
    ///
    /// # Default Values
    /// * `period`: 20 periods
    /// * `std_dev_multiplier`: 1.8 (more sensitive than standard 2.0)
    /// * `trend_ma_period`: 30 periods (more responsive trend detection)
    fn default() -> Self {
        Self {
            period: 20,
            std_dev_multiplier: 1.8, // Reduced from 2.0 to be more sensitive
            price_history: VecDeque::new(),
            volume_history: VecDeque::new(),
            position_open: false,
            current_position: None,
            trend_ma_period: 30, // Reduced from 50 to be more responsive
        }
    }
}

impl BollingerBands {
    /// Creates a new Bollinger Bands strategy with custom parameters.
    ///
    /// # Arguments
    /// * `period`: Number of periods to use for band calculation
    /// * `std_dev_multiplier`: Multiplier for standard deviation bands
    ///
    /// # Returns
    /// A new `BollingerBands` instance with the specified configuration
    pub fn new(period: usize, std_dev_multiplier: f64) -> Self {
        Self {
            period,
            std_dev_multiplier,
            price_history: VecDeque::new(),
            volume_history: VecDeque::new(),
            position_open: false,
            current_position: None,
            trend_ma_period: 30,
        }
    }

    /// Calculates Bollinger Bands for the current price history.
    ///
    /// Computes the upper, middle, and lower bands using the specified period
    /// and standard deviation multiplier.
    ///
    /// # Returns
    /// An `Option` containing the (upper, middle, lower) band values,
    /// or `None` if insufficient price history
    fn calculate_bands(&self) -> Option<(f64, f64, f64)> {
        if self.price_history.len() < self.period {
            return None;
        }

        // Only use the most recent period prices
        let prices: Vec<f64> = self
            .price_history
            .iter()
            .rev()
            .take(self.period)
            .copied()
            .collect();
        let mean = prices.iter().sum::<f64>() / self.period as f64;

        let variance = prices
            .iter()
            .map(|price| {
                let diff = price - mean;
                diff * diff
            })
            .sum::<f64>()
            / self.period as f64;

        let std_dev = variance.sqrt();
        let band_width = std_dev * self.std_dev_multiplier;

        Some((mean + band_width, mean, mean - band_width))
    }

    /// Detects the current market trend using moving average crossover.
    ///
    /// Uses 8-period and 15-period moving averages to determine trend direction.
    ///
    /// # Returns
    /// An `Option` containing the detected trend (`Position::Long` or `Position::Short`),
    /// or `None` if trend cannot be determined
    fn detect_trend(&self) -> Option<Position> {
        if self.price_history.len() < 15 {
            return None;
        }

        let prices: Vec<f64> = self.price_history.iter().copied().collect();
        let current_price = prices[0];

        // Calculate 8-period and 15-period MAs for faster trend detection
        let ma_8: f64 = prices.iter().take(8).sum::<f64>() / 8.0;
        let ma_15: f64 = prices.iter().take(15).sum::<f64>() / 15.0;

        // Determine trend based on MA crossover and price position
        if ma_8 > ma_15 && current_price > ma_8 {
            Some(Position::Long)
        } else if ma_8 < ma_15 && current_price < ma_8 {
            Some(Position::Short)
        } else {
            None
        }
    }

    /// Analyzes a single market data point and generates a trading signal.
    ///
    /// Updates price and volume history, calculates Bollinger Bands,
    /// detects market trend, and generates a trading signal.
    ///
    /// # Arguments
    /// * `market_data`: Processed market data point to analyze
    ///
    /// # Returns
    /// A `BollingerSignal` with the recommended trading action
    pub fn analyze(&mut self, market_data: &ProcessedMarketData) -> BollingerSignal {
        // Update price history
        self.price_history.push_front(market_data.raw_data.price);
        if self.price_history.len() > self.period * 2 {
            self.price_history.pop_back();
        }

        // Update volume history
        self.volume_history.push_front(market_data.raw_data.volume);
        if self.volume_history.len() > self.period {
            self.volume_history.pop_back();
        }

        // Calculate bands
        let (upper, middle, lower) = match self.calculate_bands() {
            Some(bands) => bands,
            None => {
                // Not enough data yet, return hold signal
                return BollingerSignal {
                    timestamp: market_data.raw_data.timestamp,
                    price: market_data.raw_data.price,
                    bands: BandLevels {
                        upper: market_data.raw_data.price,
                        middle: market_data.raw_data.price,
                        lower: market_data.raw_data.price,
                    },
                    signal_type: SignalType::Hold,
                };
            }
        };

        let current_price = market_data.raw_data.price;
        let trend = self.detect_trend();

        // Generate signal based on price position and trend
        let signal = match trend {
            Some(Position::Long) => {
                if current_price <= lower {
                    SignalType::Buy
                } else if current_price >= middle + (upper - middle) * 0.8 {
                    SignalType::Sell
                } else {
                    SignalType::Hold
                }
            }
            Some(Position::Short) => {
                if current_price >= upper {
                    SignalType::Sell
                } else if current_price <= middle - (middle - lower) * 0.8 {
                    SignalType::Buy
                } else {
                    SignalType::Hold
                }
            }
            None => {
                if current_price >= upper {
                    SignalType::Sell
                } else if current_price <= lower {
                    SignalType::Buy
                } else {
                    SignalType::Hold
                }
            }
        };

        BollingerSignal {
            timestamp: market_data.raw_data.timestamp,
            price: current_price,
            bands: BandLevels {
                upper,
                middle,
                lower,
            },
            signal_type: signal,
        }
    }

    /// Analyzes a batch of market data points and generates trading signals.
    ///
    /// Applies the `analyze` method to each market data point in the input slice.
    ///
    /// # Arguments
    /// * `data`: Slice of processed market data points to analyze
    ///
    /// # Returns
    /// A vector of `BollingerSignal` with trading signals for each data point
    pub fn _analyze_batch(&mut self, data: &[ProcessedMarketData]) -> Vec<BollingerSignal> {
        data.iter().map(|d| self.analyze(d)).collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::data::MarketData;

    fn create_test_data(price: f64) -> ProcessedMarketData {
        ProcessedMarketData {
            raw_data: MarketData {
                timestamp: chrono::Utc::now(),
                symbol: "TEST".to_string(),
                price,
                volume: 1000.0,
                high: price + 1.0,
                low: price - 1.0,
            },
            moving_average_5: Some(price),
            moving_average_20: Some(price),
            rsi_14: Some(50.0),
            volatility: Some(1.0),
            is_outlier: false,
        }
    }

    #[test]
    fn test_bollinger_bands_calculation() {
        let mut strategy = BollingerBands::new(5, 2.0);

        // Add a series of prices
        let prices = vec![100.0, 101.0, 99.0, 102.0, 98.0];
        for price in prices {
            let data = create_test_data(price);
            strategy.analyze(&data);
        }

        let signal = strategy.analyze(&create_test_data(95.0)); // Price below lower band
        assert!(matches!(signal.signal_type, SignalType::Buy));

        let signal = strategy.analyze(&create_test_data(105.0)); // Price above upper band
        assert!(matches!(signal.signal_type, SignalType::Sell));
    }

    #[test]
    fn test_position_management() {
        let mut strategy = BollingerBands::new(5, 2.0);

        // Initialize with some data
        for _ in 0..5 {
            let data = create_test_data(100.0);
            strategy.analyze(&data);
        }

        // Test opening and closing a long position
        let signal = strategy.analyze(&create_test_data(95.0)); // Should open long
        assert!(matches!(signal.signal_type, SignalType::Buy));
        assert!(strategy.position_open);

        let signal = strategy.analyze(&create_test_data(100.0)); // Should close at middle band
        assert!(matches!(signal.signal_type, SignalType::Hold));
        assert!(!strategy.position_open);
    }
}
